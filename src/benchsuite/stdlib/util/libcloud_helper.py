# Benchmarking Suite
# Copyright 2014-2017 Engineering Ingegneria Informatica S.p.A.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Developed in the ARTIST EU project (www.artist-project.eu) and in the
# CloudPerfect EU project (https://cloudperfect.eu/)

import logging
import random
import re
import string
from abc import ABC, abstractmethod

from libcloud.compute.base import KeyPair
from libcloud.compute.providers import get_driver

from benchsuite.core.model.exception import ProviderConfigurationException

logger = logging.getLogger(__name__)

BENCHSUITE_SECURITY_GROUP_NAME = 'benchsuite_sg'
BENCHSUITE_SECURITY_GROUP_DESCRIPTION = \
    'Automatically generated by the Benchmarking Suite'


def get_helper(libcloud_type):
    """return the correct implementation of the Helper based on the type
    of the cloud"""
    return {
        'openstack': OpenstackHelper(),
        'ec2': EC2Helper()
    }[libcloud_type]


class LibCloudHelper(ABC):

    @abstractmethod
    def get_driver(self, access_id, secret_key, extra_params):
        pass

    @abstractmethod
    def get_security_group(self, driver, security_group_name):
        pass

    @abstractmethod
    def get_network(self, driver, network_name):
        pass

    def create_keypair(self, driver):
        rand_name = ''.join(
            [random.choice(string.ascii_lowercase + string.digits) for i in
             range(6)])
        keypair_name = 'benchsuite_key-' + rand_name
        keypair = driver.create_key_pair(keypair_name)
        logger.info('New keypair created with name \'%s\'', keypair_name)
        return keypair.name, keypair.private_key

    def destroy_keypair(self, driver, keypair_name):
        keypair = KeyPair(keypair_name, None, None, None)
        driver.delete_key_pair(keypair)
        logger.info('Keypair \'%s\' destroyed', keypair.name)


class OpenstackHelper(LibCloudHelper):

    def get_driver(self, access_id, secret_key, extra_params):

        driver = None

        drv = get_driver('openstack')

        if 'auth_version' not in extra_params:
            # auth version not provided. trying with the two most common
            try:
                logger.info(
                    'Authentication version not specified. Trying with 2.0_password')
                newparms = dict(extra_params)
                newparms['ex_force_auth_version'] = '2.0_password'
                driver = drv(access_id, secret_key, **newparms)
                driver.list_sizes()  # try a call to the API
                return driver
            except Exception as ex:
                logger.warning(
                    'Authentication failed with exception: ' + str(ex))
                logger.info('Trying authentication with 3.x_password')
                try:
                    newparms = dict(extra_params)
                    newparms['ex_force_auth_version'] = '3.x_password'
                    driver = drv(access_id, secret_key, **newparms)
                    driver.list_sizes()  # try a call to the API
                    return driver
                except Exception as ex:
                    logger.warning(
                        'Authentication failed with exception: ' + str(ex))
                    logger.error('Tried to authenticate with 2.0_password '
                                 'and 3.x_password without success. Please'
                                 ' specify the "auth_version" parameter manually')
                    return driver
        else:
            return drv(access_id, secret_key, **extra_params)

    def get_security_group(self, driver, security_group_name):
        if security_group_name == None:
            logger.debug('Security group name not specified. '
                         'Using the automatically generated security group "benchsuite_sg"')
            security_group_name = BENCHSUITE_SECURITY_GROUP_NAME

        all_security_groups = driver.ex_list_security_groups()

        selected_security_groups = [s for s in all_security_groups if
                                    s.name == security_group_name or s.id == security_group_name]

        if len(selected_security_groups) >= 1:
            return {'ex_security_groups': [selected_security_groups[0]]}
        else:
            if security_group_name == BENCHSUITE_SECURITY_GROUP_NAME:
                logger.warning(
                    'Security group not found. Creating the "benchsuite_sg" security group')
                # create it
                sg = driver.ex_create_security_group(
                    BENCHSUITE_SECURITY_GROUP_NAME,
                    BENCHSUITE_SECURITY_GROUP_DESCRIPTION)
                driver.ex_create_security_group_rule(sg, 'tcp', 22, 22)
                return {'ex_security_groups': [sg]}
            else:
                raise ProviderConfigurationException(
                    'The requested security group "{0}" does not exist'.format(
                        security_group_name))

    def get_network(self, driver, network_name):

        if not network_name:
            # openstack allow to not specify the network
            return None

        all_networks = driver.ex_list_networks()
        selected_networks = [n for n in all_networks
                             if n.name == network_name or n.id == network_name]

        if not selected_networks:
            raise ProviderConfigurationException(
                'The requested network "{0}" does not exist'.format(
                    network_name))

        if len(selected_networks) > 1:
            logger.warning(
                'Multiple networks matches the requested network. Selecting the first one')

        return {'networks': [selected_networks[0]]}


class EC2Helper(LibCloudHelper):

    def get_driver(self, access_id, secret_key, extra_params):
        drv = get_driver('ec2')
        return drv(access_id, secret_key, **extra_params)

    def get_security_group(self, driver, security_group_name):
        if security_group_name == None:
            logger.debug('Security group name not specified. '
                         'Using the automatically generated security group "benchsuite_sg"')
            security_group_name = BENCHSUITE_SECURITY_GROUP_NAME

        all_security_groups = driver.ex_get_security_groups()

        selected_security_groups = [s for s in all_security_groups
                                    if
                                    s.name == security_group_name or s.id == security_group_name]

        if len(selected_security_groups) >= 1:
            return {'ex_security_group_ids': selected_security_groups[0].id}
        else:
            if security_group_name == BENCHSUITE_SECURITY_GROUP_NAME:
                logger.warning(
                    'Security group not found. Creating the "benchsuite_sg" security group')
                sg = driver.ex_create_security_group(
                    BENCHSUITE_SECURITY_GROUP_NAME,
                    BENCHSUITE_SECURITY_GROUP_DESCRIPTION)
                driver.ex_authorize_security_group(
                    BENCHSUITE_SECURITY_GROUP_NAME,
                    22, 22, '0.0.0.0/0',
                    protocol='tcp')
                return {'ex_security_group_ids': sg.id}
            else:
                raise ProviderConfigurationException(
                    'The requested security group "{0}" does not exist'.format(
                        security_group_name))

    def get_network(self, driver, network_name):

        all_networks = driver.ex_list_subnets()

        if not network_name:
            if len(all_networks) == 1:
                logger.info(
                    'Network "%s" automatically selected because it is the only one')
                return {'ex_subnet': all_networks[0]}
            else:
                # this will lead to an exception because ec2 request a network
                # when a security_group is used
                return None

        selected_networks = [n for n in all_networks
                             if n.name == network_name or n.id == network_name]

        if not selected_networks:
            raise ProviderConfigurationException(
                'The requested network "{0}" does not exist'.format(
                    network_name))

        if len(selected_networks) > 1:
            logger.warning(
                'Multiple networks matches the requested network. Selecting the first one')

        return {'ex_subnet': selected_networks[0]}


def guess_platform(image):
    """try to extract the platform data from the image"""

    name = image.name

    if re.search(r'ubuntu', name, re.IGNORECASE):
        m = re.search(r'[^0-9]([0-9]{2})(\.|_|-)?([0-9]{2})([^0-9]|$)', name)
        if m:
            return 'ubuntu_' + m.group(1) + '_' + m.group(3)
        else:
            m = re.search(r'[^0-9]([0-9]{2})([^0-9]|$)', name)
            if m:
                return 'ubuntu_' + m.group(1)
            else:
                if re.search(r'xenial', name, re.IGNORECASE):
                    return 'ubuntu_16_04'
                if re.search(r'trusty', name, re.IGNORECASE):
                    return 'ubuntu_14_04'

                return 'ubuntu'

    elif re.search(r'centos', name, re.IGNORECASE):
        m = re.search(r'[^0-9]([0-9])([^0-9]|$)', name)
        if m:
            return 'centos_' + m.group(1)
        else:
            return 'centos'

    return 'default'

def guess_username(platform):
    if platform.startswith('ubuntu'):
        return 'ubuntu'
    elif platform.startswith('centos'):
        return 'centos'
    else:
        return 'root'
